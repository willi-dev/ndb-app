__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  var ReactCurrentOwner = _require(_dependencyMap[0], './ReactCurrentOwner');

  var ReactComponentTreeHook = _require(_dependencyMap[1], './ReactComponentTreeHook');

  var ReactElement = _require(_dependencyMap[2], './ReactElement');

  var checkReactTypeSpec = _require(_dependencyMap[3], './checkReactTypeSpec');

  var canDefineProperty = _require(_dependencyMap[4], './canDefineProperty');

  var getIteratorFn = _require(_dependencyMap[5], './getIteratorFn');

  var warning = _require(_dependencyMap[6], "fbjs/lib/warning");

  var lowPriorityWarning = _require(_dependencyMap[7], './lowPriorityWarning');

  function getDeclarationErrorAddendum() {
    if (ReactCurrentOwner.current) {
      var name = ReactCurrentOwner.current.getName();

      if (name) {
        return ' Check the render method of `' + name + '`.';
      }
    }

    return '';
  }

  function getSourceInfoErrorAddendum(elementProps) {
    if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
      var source = elementProps.__source;
      var fileName = source.fileName.replace(/^.*[\\\/]/, '');
      var lineNumber = source.lineNumber;
      return ' Check your code at ' + fileName + ':' + lineNumber + '.';
    }

    return '';
  }

  var ownerHasKeyUseWarning = {};

  function getCurrentComponentErrorInfo(parentType) {
    var info = getDeclarationErrorAddendum();

    if (!info) {
      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

      if (parentName) {
        info = ' Check the top-level render call using <' + parentName + '>.';
      }
    }

    return info;
  }

  function validateExplicitKey(element, parentType) {
    if (!element._store || element._store.validated || element.key != null) {
      return;
    }

    element._store.validated = true;
    var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});
    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

    if (memoizer[currentComponentErrorInfo]) {
      return;
    }

    memoizer[currentComponentErrorInfo] = true;
    var childOwner = '';

    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
      childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
    }

    process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
  }

  function validateChildKeys(node, parentType) {
    if (typeof node !== 'object') {
      return;
    }

    if (Array.isArray(node)) {
      for (var i = 0; i < node.length; i++) {
        var child = node[i];

        if (ReactElement.isValidElement(child)) {
          validateExplicitKey(child, parentType);
        }
      }
    } else if (ReactElement.isValidElement(node)) {
      if (node._store) {
        node._store.validated = true;
      }
    } else if (node) {
      var iteratorFn = getIteratorFn(node);

      if (iteratorFn) {
        if (iteratorFn !== node.entries) {
          var iterator = iteratorFn.call(node);
          var step;

          while (!(step = iterator.next()).done) {
            if (ReactElement.isValidElement(step.value)) {
              validateExplicitKey(step.value, parentType);
            }
          }
        }
      }
    }
  }

  function validatePropTypes(element) {
    var componentClass = element.type;

    if (typeof componentClass !== 'function') {
      return;
    }

    var name = componentClass.displayName || componentClass.name;

    if (componentClass.propTypes) {
      checkReactTypeSpec(componentClass.propTypes, element.props, 'prop', name, element, null);
    }

    if (typeof componentClass.getDefaultProps === 'function') {
      process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
    }
  }

  var ReactElementValidator = {
    createElement: function createElement(type, props, children) {
      var validType = typeof type === 'string' || typeof type === 'function';

      if (!validType) {
        if (typeof type !== 'function' && typeof type !== 'string') {
          var info = '';

          if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
            info += ' You likely forgot to export your component from the file ' + "it's defined in.";
          }

          var sourceInfo = getSourceInfoErrorAddendum(props);

          if (sourceInfo) {
            info += sourceInfo;
          } else {
            info += getDeclarationErrorAddendum();
          }

          info += ReactComponentTreeHook.getCurrentStackAddendum();
          var currentSource = props !== null && props !== undefined && props.__source !== undefined ? props.__source : null;
          ReactComponentTreeHook.pushNonStandardWarningStack(true, currentSource);
          process.env.NODE_ENV !== 'production' ? warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info) : void 0;
          ReactComponentTreeHook.popNonStandardWarningStack();
        }
      }

      var element = ReactElement.createElement.apply(this, arguments);

      if (element == null) {
        return element;
      }

      if (validType) {
        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], type);
        }
      }

      validatePropTypes(element);
      return element;
    },
    createFactory: function createFactory(type) {
      var validatedFactory = ReactElementValidator.createElement.bind(null, type);
      validatedFactory.type = type;

      if (process.env.NODE_ENV !== 'production') {
        if (canDefineProperty) {
          Object.defineProperty(validatedFactory, 'type', {
            enumerable: false,
            get: function get() {
              lowPriorityWarning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
              Object.defineProperty(this, 'type', {
                value: type
              });
              return type;
            }
          });
        }
      }

      return validatedFactory;
    },
    cloneElement: function cloneElement(element, props, children) {
      var newElement = ReactElement.cloneElement.apply(this, arguments);

      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], newElement.type);
      }

      validatePropTypes(newElement);
      return newElement;
    }
  };
  module.exports = ReactElementValidator;
});